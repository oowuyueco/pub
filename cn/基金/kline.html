<!DOCTYPE html>
<html lang="en" style="background: #FFFFFF;height: 100%">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="KLineChart example" />
    <title>KLineChart + js</title>
    <script type="text/javascript" src="../../js/klinecharts.min.js"></script>
    <script type="text/javascript" src="../../js/indicatorCalculation.js"></script>
    <script type="text/javascript" src="../../js/my.js"></script>

    <script>

        let jsLoadCount = 0
        function checkOrTryHttpNew(dataName, dataType, fuc) {
            var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement

            var JS1 = document.createElement("script")
            if (dataType == "futures") {
                JS1.src = `../æ–°æµªæœŸè´§è¡Œæƒ…/${dataName}.js`
            }
            else {
                JS1.src = `../è¡Œæƒ…/${dataName}.js`
                if (dataName.includes("æ ‡æ™®") || dataName.includes("çº³æŒ‡") || dataName.includes("é“ç¼æ–¯"))
                    JS1.src = `../è¡Œæƒ…/${dataName}.js`
            }

            var JS2 = document.createElement("script")
            JS2.src = `../../../../tempData/testç­–ç•¥.js`

            JS1.onload = JS2.onload = function () {
                jsLoadCount++
                if (jsLoadCount == 2 && fuc) {
                    window.trigDateArr = typeof testç­–ç•¥ !== "undefined" && typeof testç­–ç•¥[dataName] !== "undefined" ? testç­–ç•¥[dataName] : []
                    window.unionAll = typeof testç­–ç•¥ !== "undefined" && typeof testç­–ç•¥?.unionAll ? testç­–ç•¥?.unionAll : []
                    //console.log(window.unionAll)
                    fuc()
                }
            }
            JS1.onerror = JS2.onerror = function (e) { console.error(e) }


            head.insertBefore(JS1, head.firstChild);
            head.insertBefore(JS2, head.firstChild);
        }

        function calculationPsy(data, period = 12, maPeriod = 6) {
            if (data.length < period) {
                //console.warn(`æ•°æ®é•¿åº¦ä¸è¶³ï¼Œè‡³å°‘éœ€è¦${period}ä¸ªäº¤æ˜“æ—¥æ•°æ®`);
                return data;
            }

            // ç”¨äºæ»‘åŠ¨çª—å£è®¡ç®—
            let upDaysCount = 0;
            let psySum = 0;
            const psyWindow = [];

            for (let i = 0; i < data.length; i++) {
                // åˆå§‹åŒ–å±æ€§
                data[i].psy = null;
                data[i].psyma = null;

                // è·³è¿‡ç¬¬ä¸€å¤©ï¼ˆæ²¡æœ‰å‰ä¸€æ—¥æ•°æ®ï¼‰
                if (i === 0) continue;

                // åˆ¤æ–­å½“å‰æ—¥æ˜¯å¦ä¸Šæ¶¨
                const isUp = data[i].close > data[i - 1].close;

                // å¦‚æœæ˜¯ä¸Šæ¶¨æ—¥ï¼Œè®¡æ•°å¢åŠ 
                if (isUp) {
                    upDaysCount++;
                }

                // å½“è¾¾åˆ°è®¡ç®—PSYçš„æœ€å°å¤©æ•°æ—¶
                if (i >= period - 1) {
                    // è®¡ç®—PSY
                    const psyValue = (upDaysCount / period) * 100;
                    data[i].psy = parseFloat(psyValue.toFixed(2));

                    // å°†PSYå€¼æ·»åŠ åˆ°çª—å£ç”¨äºè®¡ç®—ç§»åŠ¨å¹³å‡
                    psyWindow.push(data[i].psy);
                    psySum += data[i].psy;

                    // å¦‚æœçª—å£å¤§å°è¶…è¿‡ç§»åŠ¨å¹³å‡å‘¨æœŸï¼Œç§»é™¤æœ€æ—§çš„å€¼
                    if (psyWindow.length > maPeriod) {
                        const oldestPsy = psyWindow.shift();
                        psySum -= oldestPsy;
                    }

                    // è®¡ç®—PSYMA
                    if (psyWindow.length === maPeriod) {
                        data[i].psyma = parseFloat((psySum / maPeriod).toFixed(2));
                    }

                    // å‡†å¤‡æ»‘åŠ¨çª—å£ï¼šç§»é™¤æœ€æ—§çš„ä¸€å¤©ï¼ˆå¦‚æœå·²ç»ä¸åœ¨å½“å‰PSYè®¡ç®—çª—å£å†…ï¼‰
                    // æ£€æŸ¥i-period+1å¤©ï¼ˆå³å°†ç§»å‡ºçª—å£çš„é‚£å¤©ï¼‰æ˜¯å¦ä¸Šæ¶¨
                    if (i >= period) {
                        const dayToRemove = i - period + 1;
                        if (dayToRemove > 0 && data[dayToRemove].close > data[dayToRemove - 1].close) {
                            upDaysCount--;
                        }
                    }
                }
            }

            return data;
        }
        function calculationRoc(dataList, params = [12, 6]) {
            const result = []
            let rocSum = 0
            return dataList.map((kLineData, i) => {
                const roc = {}
                if (i >= params[0] - 1) {
                    const close = kLineData.close
                    const agoClose = (dataList[i - params[0]] || dataList[i - (params[0] - 1)]).close
                    if (agoClose !== 0) {
                        roc.roc = (close - agoClose) / agoClose * 100
                    } else {
                        roc.roc = 0
                    }
                    rocSum += roc.roc
                    if (i >= params[0] - 1 + params[1] - 1) {
                        roc.maRoc = rocSum / params[1]
                        rocSum -= result[i - (params[1] - 1)].roc
                    }
                }
                result.push(roc)
                kLineData.roc = roc
                return kLineData
            })
        }
        Array.prototype.cal9è½¬ = function (klineäº¤æ˜“æ—¥, priod, N = 5) {
            var candleList = this
            if (candleList.length < 20) return candleList

            for (let endIndex = candleList.length - 1; candleList.length - N <= endIndex; endIndex--) {

                if (endIndex == candleList.length - 1) {
                    if (priod == "week" && new Date(klineäº¤æ˜“æ—¥).getDay() < 3) continue
                    if (priod == "month" && +klineäº¤æ˜“æ—¥.substring(8, 10) < 18) continue
                }

                let is9è½¬up = true
                let is9è½¬down = true
                for (var i = 0; i <= 8; i++) {
                    is9è½¬down = is9è½¬down && (candleList[endIndex - i - 4].close > candleList[endIndex - i].close)
                    is9è½¬up = is9è½¬up && (candleList[endIndex - i - 4].close < candleList[endIndex - i].close)
                }

                if (is9è½¬up) {
                    for (var i = 0; i <= 8; i++)
                        candleList[endIndex - i]["is9è½¬up"] = 9 - i
                    //break
                }
                if (is9è½¬down) {
                    for (var i = 0; i <= 8; i++)
                        candleList[endIndex - i]["is9è½¬down"] = 9 - i
                    //break
                }
            }

            return candleList
        }


    </script>
</head>

<body style="margin: 0;height: 100%">
    <div id="chartDay" style="height:80%"></div>
    <div id="chartWeek" style="height:80%"></div>
    <div id="chartMonth" style="height:80%"></div>

    <!-- <div id="chartDay" style="height:20%"></div>
    <div id="chartWeek" style="height:40%"></div>
    <div id="chartMonth" style="height:40%"></div> -->

    <script>
        var chartDay = klinecharts.init('chartDay')
        var chartWeek = klinecharts.init('chartWeek')
        var chartMonth = klinecharts.init('chartMonth')

        var dataType = decodeURI(getQueryVariable("dataType"))
        var dataName = decodeURI(getQueryVariable("name"))
        var edate = getQueryVariable("edate") //æ€»å›æµ‹æ•°æ® 70å¼€å§‹  endateç»“æŸ
        var backday = getQueryVariable("backday") //å›æµ‹å¼€å§‹ç‚¹ ç»“æŸå¾€å‰å¤©æ•°
        var noChart = getQueryVariable("noChart")  // ?dataType=xueqiu&name=æ²ªæ·±300&edate=2018-10-19&&backday=2

        //ç­‰æ•ˆforå¾ªç¯for1
        var currentDayIndex
        var endIndex
        var conditon1 = []
        var conditon12 = []
        var logNameDateCondAtter = []

        checkOrTryHttpNew(dataName, dataType, () => {
            //ç»Ÿä¸€æ•°æ®
            let dayDatas = window[dataName]
            if (!dayDatas[0]?.timestamp)
                dayDatas = dayDatas.map(function (data) {
                    data.timestamp = new Date(data.date).getTime()
                    return data
                })
            let weekDatas = dayToPeriod(dayDatas, "week")

            klinecharts.registerIndicator({
                name: 'new9è½¬',
                figures: [
                    { key: 'drawY' }
                ],
                calc: (kLineDataList) => {
                    return kLineDataList.map(
                        kLineData => ({
                            drawUps: kLineData.ups,
                            drawLows: kLineData.lows,
                            is9è½¬up: kLineData.is9è½¬up,
                            is9è½¬down: kLineData.is9è½¬down,
                            text: kLineData.is9è½¬up ?? kLineData.is9è½¬down //fruits[Math.floor(Math.random() * 17)]
                        }))
                },
                draw: ({
                    ctx,
                    barSpace,
                    visibleRange,
                    indicator,
                    xAxis,
                    yAxis
                }) => {
                    const fruits = [
                        'ğŸ', 'ğŸ', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ',
                        'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸˆ', 'ğŸ’', 'ğŸ‘',
                        'ğŸ', 'ğŸ¥¥', 'ğŸ¥', 'ğŸ¥­', 'ğŸ¥‘', 'ğŸ'
                    ]
                    const { from, to } = visibleRange
                    ctx.font = barSpace.gapBar * 1.5 + 'px' + ' Helvetica Neue'
                    ctx.textAlign = 'center'
                    const result = indicator.result
                    for (let i = from; i < to; i++) {
                        const data = result[i]
                        const x = xAxis.convertToPixel(i)
                        let drawText = ""
                        if (data.is9è½¬up || data.is9è½¬down)
                            drawText = data.is9è½¬up ?? data.is9è½¬down  //fruits[Math.floor(Math.random() * 17)] //data.is9è½¬down
                        ctx.fillStyle = data.is9è½¬up ? "red" : "green"
                        let y = data.is9è½¬up ? yAxis.convertToPixel(data.drawLows) + 15 : yAxis.convertToPixel(data.drawUps) - 15
                        ctx.fillText(drawText, x, y)
                    }
                    return false
                }
            })
            klinecharts.registerIndicator({
                name: 'newBOLL',
                shortName: 'newBOLL',
                calcParams: [],
                figures: [
                    { key: 'ups', title: 'ups: ', type: 'line' },
                    { key: 'mas', title: 'mas: ', type: 'line' },
                    { key: 'lows', title: 'lows: ', type: 'line' },
                ],
                styles: {},
                calc: (kLineDataList, { calcParams, figures }) => {
                    return kLineDataList.map((kLineData, i) => {
                        return {
                            "ups": kLineData.ups,
                            "mas": kLineData.mas,
                            "lows": kLineData.lows
                        }
                    })
                }
            })
            klinecharts.registerIndicator({
                name: 'newKDJ',
                shortName: 'newKDJ',
                calcParams: [],
                figures: [
                    { key: 'K', title: 'K: ', type: 'line' },
                    { key: 'D', title: 'D: ', type: 'line' },
                    { key: 'J', title: 'J: ', type: 'line' },
                ],
                styles: {},
                calc: (kLineDataList, { calcParams, figures }) => {
                    return kLineDataList.map((kLineData, i) => {
                        return {
                            "K": kLineData.K,
                            "D": kLineData.D,
                            "J": kLineData.J
                        }
                    })
                }
            })
            klinecharts.registerIndicator({
                name: 'newMACD',
                shortName: 'newMACD',
                calcParams: [],
                figures: [
                    { key: 'diff', title: 'diff: ', type: 'line' },
                    { key: 'dea', title: 'dea: ', type: 'line' },
                    { key: 'bar', title: 'bar: ', type: 'line' },
                ],
                styles: {},
                calc: (kLineDataList, { calcParams, figures }) => {
                    return kLineDataList.map((kLineData, i) => {
                        return {
                            "diff": kLineData.diff,
                            "dea": kLineData.dea,
                            "bar": kLineData.bar
                        }
                    })
                },
            })
            klinecharts.registerIndicator({
                name: 'newBias',
                shortName: 'newBias',
                calcParams: [],
                figures: [
                    { key: 'bias1', title: 'bias6ï¼š', type: 'line' },
                    { key: 'bias2', title: 'bias12ï¼š', type: 'line' },
                    { key: 'bias3', title: 'bias24ï¼š', type: 'line' },
                ],
                styles: {},
                calc: (kLineDataList, { calcParams, figures }) => {
                    return kLineDataList.map((kLineData, i) => {
                        return {
                            "bias1": kLineData.bias.bias1,
                            "bias2": kLineData.bias.bias2,
                            "bias3": kLineData.bias.bias3,
                        }
                    })
                }
            })
            klinecharts.registerIndicator({
                name: 'newWvad',
                shortName: 'newWvad',
                calcParams: [],
                figures: [
                    { key: 'wvad', title: 'wvad:', type: 'line' },
                    { key: 'wvadMa6', title: 'wvadMa6:', type: 'line' },

                ],
                styles: {},
                calc: (kLineDataList, { calcParams, figures }) => {
                    return kLineDataList.map((kLineData, i) => {
                        console.log(kLineData.date, kLineData)
                        return {
                            "wvad": kLineData?.wvad?.wvad ? kLineData.wvad.wvad / 10000000000000 : undefined,
                            "wvadMa6": kLineData?.wvad?.wvadMa6 ? kLineData.wvad.wvadMa6 / 10000000000000 : undefined,

                        }
                    })
                }
            })

            klinecharts.registerIndicator({
                name: 'newTest1',
                shortName: 'newTest1',
                calcParams: [],
                figures: [
                    { key: 'count', title: 'count: ', type: 'bar' },
                ],
                styles: {},
                calc: (kLineDataList, { calcParams, figures }) => {
                    return kLineDataList.map((kLineData, i) => {
                        let count = null
                        let findele = window.unionAll.find(ele => ele[0] == kLineData.date)
                        if (findele && (findele[2].split(',').includes(window.dataName) || findele[1] > 112)) count = findele[1]
                        return {
                            "count": count
                        }
                    })
                }
            })
            klinecharts.registerIndicator({
                name: 'newTest2',
                figures: [
                    { key: 'drawY' }
                ],
                calc: (kLineDataList) => {
                    return kLineDataList.map(
                        (kLineData) => ({
                            drawUps: kLineData.ups,
                            drawLows: kLineData.lows,
                            date: kLineData.date,
                            trig: window.testç­–ç•¥["unionAll"].find((value, index) => {
                                return value[0] == kLineData.date
                            })
                        }))
                },
                draw: ({
                    ctx,
                    barSpace,
                    visibleRange,
                    indicator,
                    xAxis,
                    yAxis
                }) => {
                    const fruits = [
                        'ğŸ', 'ğŸ', 'ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ',
                        'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸˆ', 'ğŸ’', 'ğŸ‘',
                        'ğŸ', 'ğŸ¥¥', 'ğŸ¥', 'ğŸ¥­', 'ğŸ¥‘', 'ğŸ'
                    ]
                    const { from, to } = visibleRange
                    ctx.font = barSpace.gapBar * 3.5 + 'px' + ' Helvetica Neue'
                    ctx.textAlign = 'center'
                    const result = indicator.result
                    for (let i = from; i < to; i++) {
                        const data = result[i]

                        const x = xAxis.convertToPixel(i)
                        let drawText = ""
                        if (data.trig)
                            drawText = "ğŸ‘†K"//fruits[1]  // data.is9è½¬up ?? data.is9è½¬down  //fruits[Math.floor(Math.random() * 17)] //data.is9è½¬down
                        ctx.fillStyle = data.trig ? "black" : "green"
                        let y = yAxis.convertToPixel(data.drawLows) + 15// : yAxis.convertToPixel(data.drawUps) - 15
                        ctx.fillText(drawText, x, y)
                    }
                    return false
                }
            })

            let normalStyle = {
                grid: {
                    show: true,
                    horizontal: {
                        show: true,
                        size: 0.35,
                        color: 'black',
                        style: 'dashed',
                        // dashedValue: [0.5, 0.5]
                    },
                    vertical: {
                        show: true,
                        size: 0.35,
                        color: '#EDEDED',
                        style: 'dashed',
                        dashedValue: [2, 2]
                    }
                },
                candle: {
                    // èœ¡çƒ›å›¾ç±»å‹ 'candle_solid'|'candle_stroke'|'candle_up_stroke'|'candle_down_stroke'|'ohlc'|'area'
                    type: 'candle_up_stroke',
                    // èœ¡çƒ›æŸ±
                    bar: {
                        upColor: '#f50000',
                        downColor: '#009b3e',
                        noChangeColor: '#888888',

                        upBorderColor: '#f50000',
                        downBorderColor: '#009b3e',
                        noChangeBorderColor: '#888888',

                        upWickColor: '#f50000',
                        downWickColor: '#009b3e',
                        noChangeWickColor: '#888888'
                    },
                    priceMark: {
                        last: {
                            show: false //å…³é—­æœ€æ–°ä»·çº¿
                        }
                    }
                },


            }
            chartDay.setStyles(normalStyle)
            chartWeek.setStyles(normalStyle)
            chartMonth.setStyles(normalStyle)
            klinecharts.registerOverlay({
                name: 'circle',
                needDefaultPointFigure: true,
                needDefaultXAxisFigure: true,
                needDefaultYAxisFigure: true,
                totalStep: 3,
                createPointFigures: ({ coordinates }) => {
                    if (coordinates.length === 2) {
                        const xDis = Math.abs(coordinates[0].x - coordinates[1].x)
                        const yDis = Math.abs(coordinates[0].y - coordinates[1].y)
                        const radius = Math.sqrt(xDis * xDis + yDis * yDis)
                        return {
                            key: 'circle',
                            type: 'circle',
                            attrs: {
                                ...coordinates[0],
                                r: radius
                            },
                            styles: {
                                style: 'stroke_fill'
                            }
                        }
                    }
                    return []
                }
            })

            chartDay.createIndicator('VOL')
            chartDay.createIndicator('PSY')
            chartDay.createIndicator('ROC')
            chartDay.createIndicator('newBias') //BIAS  newBias
            chartDay.createIndicator({ name: "newBOLL" }, true, { id: 'candle_pane' }) //BOLL  newBOLL
            chartDay.createIndicator({ name: "new9è½¬" }, true, { id: 'candle_pane' })


            chartWeek.createIndicator('VOL')
            chartWeek.createIndicator('newWvad')
            chartWeek.createIndicator('PSY')
            chartWeek.createIndicator('ROC')
            chartWeek.createIndicator({ name: "BOLL" }, true, { id: 'candle_pane' })
            chartWeek.createIndicator({ name: "new9è½¬" }, true, { id: 'candle_pane' })

            chartMonth.createIndicator('VOL')
            chartMonth.createIndicator('newWvad')
            chartMonth.createIndicator('PSY')
            chartMonth.createIndicator('ROC')
            chartMonth.createIndicator({ name: "BOLL" }, true, { id: 'candle_pane' })
            chartMonth.createIndicator({ name: "new9è½¬" }, true, { id: 'candle_pane' })

            endIndex = dayDatas.length
            if (edate) {
                endIndex = dayDatas.findIndex(ele => ele.date == edate)
                if (endIndex == -1) endIndex = dayDatas.length
            }
            currentDayIndex = 70
            if (backday) {
                currentDayIndex = endIndex - backday
            }
            forSetInterval(currentDayIndex, endIndex, dayDatas)


            //----------------------------------------

            document.addEventListener("keydown", (event) => {
                if (event.keyCode === 88) {
                    chartDay.createOverlay("circle") //xé”®
                    return
                }

                if (event.keyCode === 37) endIndex-- //å·¦å³ä¸Šé”®
                if (event.keyCode === 39) endIndex++
                if (event.keyCode === 38) endIndex = dayDatas.length - 1 < endIndex + 100 ? dayDatas.length - 1 : endIndex + 100
                forSetInterval(endIndex, endIndex, dayDatas, true) //é‡ç½®å¯¹é½chartDay
            })

            chartDay.subscribeAction(
                'onCandleBarClick',
                (onData) => {
                    endIndex = onData.dataIndex
                    forSetInterval(endIndex, endIndex, dayDatas, true)
                    // chartDay.scrollToDataIndex(endIndex)
                    // forSetInterval(endIndex, endIndex, dayDatas, false)
                }
            )
            chartWeek.subscribeAction(
                'onCandleBarClick',
                (onData) => {
                    endIndex = dayDatas.findIndex(ele => ele.date == weekDatas[onData.dataIndex]?.date)
                    forSetInterval(endIndex, endIndex, dayDatas, true) //é‡ç½®å¯¹é½chartDay
                    // chartWeek.scrollToDataIndex(onData.dataIndex)
                    // forSetInterval(endIndex, endIndex, dayDatas, true, false)
                }
            )

            let mouseLeftDown = false
            let downDrag = false
            let dragChart = ""
            document.addEventListener('mousedown', () => { mouseLeftDown = true; downDrag = false })
            document.addEventListener('mousemove', () => { if (mouseLeftDown) downDrag = true })
            chartDay.subscribeAction(
                'onVisibleRangeChange',
                (onData) => {
                    if (mouseLeftDown && downDrag) {
                        endIndex = onData.to - 1
                        dragChart = "day"
                    }
                }
            )
            chartWeek.subscribeAction(
                'onVisibleRangeChange',
                (onData) => {
                    if (mouseLeftDown && downDrag) {
                        let newEndIndex = dayDatas.findIndex(ele => ele.date == weekDatas[onData.to - 1]?.date)
                        endIndex = endIndex < newEndIndex ? endIndex : newEndIndex
                        dragChart = "week"
                    }
                }
            )
            document.addEventListener('mouseup', () => {
                if (mouseLeftDown && downDrag && dragChart == "day") {
                    forSetInterval(endIndex, endIndex, dayDatas, true)
                }

                if (mouseLeftDown && downDrag && dragChart == "week") {
                    forSetInterval(endIndex, endIndex, dayDatas, true, true)
                }

                dragChart = ""
                downDrag = false
                mouseLeftDown = false
            })

        });


        function forSetInterval(currentDayIndex, endIndex, dayDatas, applyDay = true, applyWeek = true) {
            let timer = setInterval(function () {
                if (timer && currentDayIndex > endIndex) { //for2
                    clearInterval(timer)
                    return
                }

                let klineäº¤æ˜“æ—¥ = dayDatas[currentDayIndex]?.date

                let dayStart = (currentDayIndex + 1) - 200 > 0 ? (currentDayIndex + 1) - 200 : 0 //dayè®¡ç®—æœ€è¿‘100å¤©
                currentDayList = dayDatas.slice(dayStart, currentDayIndex + 1)
                    .calBoll().cal9è½¬(klineäº¤æ˜“æ—¥, "day").calKdj().calMacd().maN(10, "close")
                currentDayList = calculationBias(currentDayList)
                currentDayList = calculationCci(currentDayList)

                currentDayList = calculationPsy(currentDayList, 12, 6);
                currentDayList = calculationRoc(currentDayList);


                let weekDayStart = (currentDayIndex + 1) - 1000 > 0 ? (currentDayIndex + 1) - 1000 : 0 //weekæœ€è¿‘100å‘¨500å¤©
                currentWeekList = dayToPeriod(dayDatas.slice(weekDayStart, currentDayIndex + 1), "week")
                    .calBoll().cal9è½¬(klineäº¤æ˜“æ—¥, "week").calKdj().calMacd().maN(10, 'close')
                currentWeekList = calculationBias(currentWeekList)
                currentWeekList = calculationCci(currentWeekList)

                currentWeekList = calculationPsy(currentWeekList, 12, 6);
                currentWeekList = calculationRoc(currentWeekList);
                currentWeekList = calculationWvad(currentWeekList);



                let monthDayStart = 0 //monthå…¨éƒ¨
                currentMonthList = dayToPeriod(dayDatas.slice(monthDayStart, currentDayIndex + 1), "month")
                    .calBoll().cal9è½¬(klineäº¤æ˜“æ—¥, "month").calKdj().calMacd()
                    .maN(3, 'close').maN(5, 'close').maN(10, 'close').maN(80, 'close')
                currentMonthList = calculationBias(currentMonthList)
                currentMonthList = calculationCci(currentMonthList)

                currentMonthList = calculationPsy(currentMonthList, 12, 6);
                currentMonthList = calculationRoc(currentMonthList);
                currentMonthList = calculationWvad(currentMonthList);

                console.log(currentMonthList.at(-1))
                if (noChart) {
                } else {
                    //applyDayé‡ç½®å¯¹é½
                    if (applyDay) chartDay.applyNewData(currentDayList)
                    if (applyWeek) chartWeek.applyNewData(currentWeekList)
                    chartMonth.applyNewData(currentMonthList)
                }
                currentDayIndex++ //for3
            }, 1)
        }

    </script>
</body>

</html>